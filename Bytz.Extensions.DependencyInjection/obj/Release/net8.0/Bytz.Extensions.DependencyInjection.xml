<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Bytz.Extensions.DependencyInjection</name>
    </assembly>
    <members>
        <member name="T:Bytz.Extensions.DependencyInjection.Contracts.IAssembly">
            <summary>
            Defines methods for locating an assembly to have classes injected from.
            </summary>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Contracts.IAssembly.InAssemblyOf``1">
            <summary>
            Use the assembly that contains a type for TClass.
            </summary>
            <typeparam name="TClass">Generic type for TClass.</typeparam>
            <returns>Type instance.</returns>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Contracts.IAssembly.InAssemblyOf(System.Type)">
            <summary>
            Use the assembly that contains a type for TClass.
            </summary>
            <param name="type">Type that has the assembly to be used.</param>
            <returns>Type instance.</returns>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Contracts.IAssembly.InAssembly(System.Reflection.Assembly)">
            <summary>
            Use the assembly that contains a type for TClass.
            </summary>
            <returns>Type instance.</returns>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Contracts.IAssembly.InThisAssembly">
            <summary>
            Use the assembly that this configuration is within.
            </summary>
            <returns>Type instance.</returns>
        </member>
        <member name="T:Bytz.Extensions.DependencyInjection.Contracts.IBytz">
            <summary>
            Marker contract. 
            </summary>
        </member>
        <member name="P:Bytz.Extensions.DependencyInjection.Contracts.IBytz.Copyright">
            <summary>
            Copyright.
            </summary>
        </member>
        <member name="T:Bytz.Extensions.DependencyInjection.Contracts.IConfigure">
            <summary>
            Configure the service collection with configured services.
            </summary>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Contracts.IConfigure.Configure">
            <summary>
            Configure the service collection
            </summary>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Contracts.IConfigure.ConfigureOrThrow">
            <summary>
            Ensures that the configuration is valid.
            </summary>
            <exception cref="T:Bytz.Extensions.DependencyInjection.Exceptions.OnlyInterfaceException">thrown if the configuration finds no types to register.</exception>
        </member>
        <member name="T:Bytz.Extensions.DependencyInjection.Contracts.IImplementing">
            <summary>
            Allow specification of the types of interfaces to register.
            </summary>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Contracts.IImplementing.AllInterfaces">
            <summary>
            Use all interfaces for registration of implementation.
            </summary>
            <returns>Lifetime instance implementing an ILifetime.</returns>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Contracts.IImplementing.OnlyInterface``1">
            <summary>
            Use only the specified interface for registration of implementation.
            </summary>
            <typeparam name="TInterface">Specific interface to register implementation.</typeparam>
            <returns>Lifetime instance implementing an ILifetime.</returns>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Contracts.IImplementing.WithoutInterfaces">
            <summary>
            Allow registration without any interfaces.
            </summary>
            <returns>Lifetime instance implementing an ILifetime.</returns>
        </member>
        <member name="T:Bytz.Extensions.DependencyInjection.Contracts.ILifetime">
            <summary>
            Allow specification of the type of lifetime.
            </summary>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Contracts.ILifetime.AsSingleton">
            <summary>
            Configure implementations as a singleton.
            </summary>
            <returns>Lifetime instance implementing an IConfigure.</returns>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Contracts.ILifetime.AsScoped">
            <summary>
            Configure implementations as scoped.
            </summary>
            <returns>Lifetime instance implementing an IConfigure.</returns>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Contracts.ILifetime.AsTransient">
            <summary>
            Configure implementations as transient.
            </summary>
            <returns>Lifetime instance implementing an IConfigure.</returns>
        </member>
        <member name="T:Bytz.Extensions.DependencyInjection.Contracts.ILocator">
            <summary>
            contract for service location.
            </summary>
        </member>
        <member name="T:Bytz.Extensions.DependencyInjection.Contracts.IType">
            <summary>
            Specify the type of classes to be configured.
            </summary>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Contracts.IType.BasedOn``1">
            <summary>
            Based on a specific type.
            </summary>
            <typeparam name="TBase">Specific base type.</typeparam>
            <returns>Lifetime instance implementing an IImplementing.</returns>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Contracts.IType.BasedOn(System.Type)">
            <summary>
            Based on a specific type.
            </summary>
            <param name="type">Specific base type.</param>
            <returns>Lifetime instance implementing an IImplementing.</returns>
            <remarks>
            Needed to register implementations based on open generics.
            </remarks>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Contracts.IType.Implementing``1">
            <summary>
            Based on classes implementing a specified interface.
            </summary>
            <typeparam name="TInterface">Specific interface.</typeparam>
            <returns>Lifetime instance implementing an IImplementing.</returns>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Contracts.IType.Only``1">
            <summary>
            Register a single type
            </summary>
            <typeparam name="TType">Specific class.</typeparam>
            <returns>Lifetime instance implementing an IImplementing contract.</returns>
        </member>
        <member name="T:Bytz.Extensions.DependencyInjection.Exceptions.AssertCountException">
            <summary>
            Exception to be thrown if the count of resolved components is not expected.
            </summary>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Exceptions.AssertCountException.#ctor(System.String)">
            <summary>
            must be constructed with a message.
            </summary>
            <param name="message">exception message.</param>
        </member>
        <member name="T:Bytz.Extensions.DependencyInjection.Exceptions.AssertLifetimeException">
            <summary>
            Exception to be thrown when a lifetime assertation fails.
            </summary>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Exceptions.AssertLifetimeException.#ctor(System.String)">
            <summary>
            must be constructed with a message.
            </summary>
            <param name="message">exception message.</param>
        </member>
        <member name="T:Bytz.Extensions.DependencyInjection.Exceptions.AssertResolutionException">
            <summary>
            Exception to be thrown if a given service cannot be resolved.
            </summary>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Exceptions.AssertResolutionException.#ctor(System.String)">
            <summary>
            must be constructed with a message.
            </summary>
            <param name="message">exception message.</param>
        </member>
        <member name="T:Bytz.Extensions.DependencyInjection.Exceptions.BytzExceptionBase">
            <summary>
            basis for bytz exceptions.
            </summary>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Exceptions.BytzExceptionBase.#ctor(System.String)">
            <summary>
            must be constructed with a message.
            </summary>
            <param name="message">exception message.</param>
        </member>
        <member name="T:Bytz.Extensions.DependencyInjection.Exceptions.NoTypesException">
            <summary>
            thrown when the configuration finds no types.
            </summary>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Exceptions.NoTypesException.#ctor(System.String)">
            <summary>
            must be constructed with a message.
            </summary>
            <param name="message">exception message.</param>
        </member>
        <member name="T:Bytz.Extensions.DependencyInjection.Exceptions.OnlyInterfaceException">
            <summary>
            thrown when types registered to only an interface cannot be cast.
            </summary>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Exceptions.OnlyInterfaceException.#ctor(System.String)">
            <summary>
            create with a message.
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:Bytz.Extensions.DependencyInjection.Configurator">
            <summary>
            Configures the service collection.
            </summary>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Configurator.Configure(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Collections.Generic.List{System.Type},Bytz.Extensions.DependencyInjection.Fluent.ContractTypes.Bases.ContractBase,Bytz.Extensions.DependencyInjection.Fluent.Lifetimes.Bases.LifetimeBase)">
            <summary>
            Configure the service collection.
            </summary>
            <param name="services">Instance of IServiceCollection.</param>
            <param name="implementations">Various implementations.</param>
            <param name="contracts">Various interfaces.</param>
            <param name="lifetimes">Various lifetimes.</param>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Configurator.Configure(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,Bytz.Extensions.DependencyInjection.Fluent.ContractTypes.Bases.ContractBase,Bytz.Extensions.DependencyInjection.Fluent.Lifetimes.Bases.LifetimeBase)">
            <summary>
            Configure 
            </summary>
            <param name="services">Instance of IServiceCollection.</param>
            <param name="implementationType">Concrete type to configure</param>
            <param name="contracts">Single contract type to implement.</param>
            <param name="lifetimes">Various lifetimes.</param>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Configurator.ConfigureImplementation(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,Bytz.Extensions.DependencyInjection.Fluent.Lifetimes.Bases.LifetimeBase)">
            <summary>
            Configure an implementation type for various lifetimes.
            </summary>
            <param name="services">Instance of IServiceCollection.</param>
            <param name="implementationType">Implementation type to be configured for the lifetime.</param>
            <param name="lifetime">Various lifetimes.</param>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Configurator.ConfigureImplementation(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,Bytz.Extensions.DependencyInjection.Fluent.Lifetimes.Transient)">
            <summary>
            Configure an implementation type as transient lifetime.
            </summary>
            <param name="services">Instance of IServiceCollection.</param>
            <param name="implementationType">Concrete type to be configured for the lifetime.</param>
            <param name="lifetime">Transient lifetime.</param>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Configurator.ConfigureImplementation(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,Bytz.Extensions.DependencyInjection.Fluent.Lifetimes.Scoped)">
            <summary>
            Configure an implementation type as a scoped lifetime.
            </summary>
            <param name="services">Instance of IServiceCollection.</param>
            <param name="implementationType">Concrete type to be configured for the lifetime.</param>
            <param name="lifetime">Scoped lifetime.</param>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Configurator.Configure(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,Bytz.Extensions.DependencyInjection.Fluent.Lifetimes.Singleton)">
            <summary>
            Configure an implementation type as a singleton with no interfaces.
            </summary>
            <param name="services">Instance of IServiceCollection.</param>
            <param name="implementationType">Concrete type to be configured for the lifetime.</param>
            <param name="lifetime">Singleton lifetime.</param>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Configurator.Configure(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,Bytz.Extensions.DependencyInjection.Fluent.ContractTypes.AllInterfaces,Bytz.Extensions.DependencyInjection.Fluent.Lifetimes.Bases.LifetimeBase)">
            <summary>
            Configure an implementation type with all interfaces.
            </summary>
            <param name="services">Instance of IServiceCollection.</param>
            <param name="implementationType">Concrete type to be configured for the lifetime.</param>
            <param name="interfaces">Configure the concrete type for all interfaces.</param>
            <param name="lifetime">Various lifetimes.</param>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Configurator.Configure(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,System.Type,Bytz.Extensions.DependencyInjection.Fluent.Lifetimes.Bases.LifetimeBase)">
            <summary>
            Configure an implementation type with all interfaces.
            </summary>
            <param name="services">Instance of IServiceCollection.</param>
            <param name="implementationType">Concrete type to be configured for the lifetime.</param>
            <param name="contractType">specific contract to configure the concrete type as.</param>
            <param name="lifetime">Various lifetimes.</param>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Configurator.Configure(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,System.Type,Bytz.Extensions.DependencyInjection.Fluent.Lifetimes.Transient)">
            <summary>
            Configure an implementation type for a specific contract type for a transient lifetime.
            </summary>
            <param name="services">Instance of IServiceCollection.</param>
            <param name="implementationType">Concrete type to be configured for the lifetime.</param>
            <param name="contractType">Various contract types.</param>
            <param name="lifetime">Transient lifetime.</param>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Configurator.Configure(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,System.Type,Bytz.Extensions.DependencyInjection.Fluent.Lifetimes.Scoped)">
            <summary>
            Configure an implementation type for a specific contract type for a scoped lifetime.
            </summary>
            <param name="services">Instance of IServiceCollection.</param>
            <param name="implementationType">Implementation type.</param>
            <param name="contractType">Contract type.</param>
            <param name="lifetime">Scoped lifetime.</param>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Configurator.Configure(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,System.Type,Bytz.Extensions.DependencyInjection.Fluent.Lifetimes.Singleton)">
            <summary>
            Configure an implementation type for a specific contract type for a singleton lifetime.
            </summary>
            <param name="services">Instance of IServiceCollection.</param>
            <param name="implementationType">Concrete type to be configured for the lifetime.</param>
            <param name="contractType">specific contract to configure the concrete type as.</param>
            <param name="lifetime">Singleton lifetime.</param>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Configurator.Configure(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,Bytz.Extensions.DependencyInjection.Fluent.ContractTypes.OnlyInterfaces,Bytz.Extensions.DependencyInjection.Fluent.Lifetimes.Bases.LifetimeBase)">
            <summary>
            Configure an implementation type for only single contract type for various lifetimes.
            </summary>
            <param name="services">Instance of IServiceCollection.</param>
            <param name="implementationType">Concrete type to be configured for the lifetime.</param>
            <param name="contracts">only a single contract.</param>
            <param name="lifetime">various lifetimes.</param>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Configurator.Configure(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,Bytz.Extensions.DependencyInjection.Fluent.ContractTypes.NoInterfaces,Bytz.Extensions.DependencyInjection.Fluent.Lifetimes.Bases.LifetimeBase)">
            <summary>
            Configure an implementation type with no interface for for various lifetimes.
            </summary>
            <param name="services">Instance of IServiceCollection.</param>
            <param name="implementationType">Concrete type to be configured for the lifetime.</param>
            <param name="contract">only a single contract.</param>
            <param name="lifetime"></param>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Configurator.Configure(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,Bytz.Extensions.DependencyInjection.Fluent.Lifetimes.Bases.LifetimeBase)">
            <summary>
            Configure an implementation type with no interface for various lifetimes.
            </summary>
            <param name="services">Instance of IServiceCollection.</param>
            <param name="implementationType">Concrete type to be configured for the lifetime.</param>
            <param name="lifetime">various lifetimes.</param>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Configurator.Configure(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,Bytz.Extensions.DependencyInjection.Fluent.Lifetimes.Transient)">
            <summary>
            Configure an implementation type with a transient lifetime.
            </summary>
            <param name="services">Instance of IServiceCollection.</param>
            <param name="implementationType">Concrete type to be configured for the lifetime.</param>
            <param name="lifetime">Transient lifetime.</param>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Configurator.Configure(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,Bytz.Extensions.DependencyInjection.Fluent.Lifetimes.Scoped)">
            <summary>
            Configure an implementation type with a scoped lifetime.
            </summary>
            <param name="services">Instance of IServiceCollection.</param>
            <param name="implementationType">Concrete type to be configured for the lifetime.</param>
            <param name="lifetime">Scoped lifetime.</param>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Configurator.ConfigureImplementation(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,Bytz.Extensions.DependencyInjection.Fluent.Lifetimes.Singleton)">
            <summary>
            Configure an implementation type with a singleton lifetime.
            </summary>
            <param name="services">Instance of IServiceCollection.</param>
            <param name="implementationType">Concrete type to be configured for the lifetime.</param>
            <param name="lifetime">Singleton lifetime.</param>
        </member>
        <member name="T:Bytz.Extensions.DependencyInjection.Fluent.ContractTypes.AllInterfaces">
            <summary>
            Register all class contracts.
            </summary>
        </member>
        <member name="T:Bytz.Extensions.DependencyInjection.Fluent.ContractTypes.Bases.ContractBase">
            <summary>
            base for all contract configurations.
            </summary>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Fluent.ContractTypes.Bases.ContractBase.#ctor">
            <summary>
            only can be created internally.
            </summary>
        </member>
        <member name="T:Bytz.Extensions.DependencyInjection.Fluent.ContractTypes.NoInterfaces">
            <summary>
            Register no contracts, register only the class as itself.
            </summary>
        </member>
        <member name="T:Bytz.Extensions.DependencyInjection.Fluent.ContractTypes.OnlyInterfaces">
            <summary>
            Register only as the specified contract.
            </summary>
        </member>
        <member name="F:Bytz.Extensions.DependencyInjection.Fluent.ContractTypes.OnlyInterfaces.Interface">
            <summary>
            Only the specific contract interface.
            </summary>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Fluent.ContractTypes.OnlyInterfaces.#ctor(System.Type)">
            <summary>
            only can be created internally, must have contract type
            </summary>
            <param name="type"></param>
        </member>
        <member name="T:Bytz.Extensions.DependencyInjection.Fluent.Implementation.BasedOn">
            <summary>
            
            </summary>
        </member>
        <member name="T:Bytz.Extensions.DependencyInjection.Fluent.Implementation.Bases.ImplementationTypeBase">
            <summary>
            
            </summary>
        </member>
        <member name="F:Bytz.Extensions.DependencyInjection.Fluent.Implementation.Bases.ImplementationTypeBase.Type">
            <summary>
            instant
            </summary>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Fluent.Implementation.Bases.ImplementationTypeBase.#ctor(System.Type)">
            <summary>
            
            </summary>
            <param name="type"></param>
        </member>
        <member name="T:Bytz.Extensions.DependencyInjection.Fluent.Implementation.Implementing">
            <summary>
            Register classes implementing a specific interface type.
            </summary>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Fluent.Implementation.Implementing.#ctor(System.Type)">
            <summary>
            Register classes implementing a specific interface.
            </summary>
            <param name="type"></param>
            <exception cref="T:System.ArgumentException">Thrown when the type parameter is not an interface.</exception>
        </member>
        <member name="T:Bytz.Extensions.DependencyInjection.Fluent.Implementation.Implementing`1">
            <summary>
            Register classes implementing a specific interface type.
            </summary>
            <typeparam name="TInterface">Type of interface to register.</typeparam>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Fluent.Implementation.Implementing`1.#ctor">
            <summary>
            Pass the interface type to the base.
            </summary>
        </member>
        <member name="T:Bytz.Extensions.DependencyInjection.Fluent.Implementation.Only">
            <summary>
            Register classes 
            </summary>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Fluent.Implementation.Only.#ctor(System.Type)">
            <summary>
            Register only the specified type.
            </summary>
            <param name="type">Concrete type to be registered.</param>
            <exception cref="T:System.ArgumentException">Thrown when the type is an interface.</exception>
        </member>
        <member name="T:Bytz.Extensions.DependencyInjection.Fluent.Lifetimes.Bases.LifetimeBase">
            <summary>
            Basis for lifetime registration.
            </summary>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Fluent.Lifetimes.Bases.LifetimeBase.#ctor">
            <summary>
            Constructor for all lifetimes.
            </summary>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Fluent.Lifetimes.Bases.LifetimeBase.AddLifetime``2(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary>
            Add a specific lifetime for an implementation type.
            </summary>
            <typeparam name="TInterface">Type of the interface implementation.</typeparam>
            <typeparam name="TImplementation">Concrete type implementing TInterface.</typeparam>
            <param name="services">Instance of a service collection.</param>
            <returns></returns>
        </member>
        <member name="T:Bytz.Extensions.DependencyInjection.Fluent.Lifetimes.Scoped">
            <summary>
            Register with a scoped lifetime.
            </summary>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Fluent.Lifetimes.Scoped.AddLifetime``2(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary>
            Add an implementation type with a specific interface.
            </summary>
            <typeparam name="TInterface">Type of the interface implementation.</typeparam>
            <typeparam name="TImplementation">Concrete type implementing TInterface.</typeparam>
            <param name="services"></param>
            <returns></returns>
        </member>
        <member name="T:Bytz.Extensions.DependencyInjection.Fluent.Lifetimes.Singleton">
            <summary>
            
            </summary>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Fluent.Lifetimes.Singleton.AddLifetime``2(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary>
            
            </summary>
            <typeparam name="TInterface">Type of the interface implementation.</typeparam>
            <typeparam name="TImplementation">Concrete type implementing TInterface.</typeparam>
            <param name="services"></param>
            <returns></returns>
        </member>
        <member name="T:Bytz.Extensions.DependencyInjection.Fluent.Lifetimes.Transient">
            <summary>
            
            </summary>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Fluent.Lifetimes.Transient.AddLifetime``2(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary>
            
            </summary>
            <typeparam name="TInterface">Type of the interface implementation.</typeparam>
            <typeparam name="TImplementation">Concrete type implementing TInterface.</typeparam>
            <param name="services"></param>
            <returns></returns>
        </member>
        <member name="T:Bytz.Extensions.DependencyInjection.Fluent.Registration.Bases.RegistrarBase">
            <summary>
            Partial implementation of the registrar.
            </summary>
            <summary>
            Partial implementation of the registrar.
            </summary>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Fluent.Registration.Bases.RegistrarBase.Configure">
            <summary>
            Configure selected services.
            </summary>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Fluent.Registration.Bases.RegistrarBase.AssertOnlyContracts(System.Collections.Generic.IList{System.Type},Bytz.Extensions.DependencyInjection.Fluent.ContractTypes.OnlyInterfaces)">
            <summary>
            Assert that all types are castable to the specified contract type.
            </summary>
            <param name="types">List of types.</param>
            <param name="onlyContract"></param>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Fluent.Registration.Bases.RegistrarBase.AssertTypeToRegister(System.Collections.Generic.List{System.Type})">
            <summary>
            assert that there are types to register.
            </summary>
            <param name="types"></param>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Fluent.Registration.Bases.RegistrarBase.SelectTypes(System.Reflection.Assembly,Bytz.Extensions.DependencyInjection.Fluent.Implementation.Bases.ImplementationTypeBase)">
            <summary>
            Get all types from that match the desired implementation type.
            </summary>
            <param name="assembly">Selected assembly.</param>
            <param name="implementationType">Selected implementation type.</param>
            <returns>All types that match the implementation type 
            within the assembly.</returns>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Fluent.Registration.Bases.RegistrarBase.InstantiableTypesIn(System.Reflection.Assembly)">
            <summary>
            Get all types from the selected assembly that are 
            not interfaces nor abstract.
            </summary>
            <param name="assembly">Selected assembly.</param>
            <returns>All instantiable types.</returns>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Fluent.Registration.Bases.RegistrarBase.GetTypesImplementing(System.Collections.Generic.List{System.Type},Bytz.Extensions.DependencyInjection.Fluent.Implementation.Bases.ImplementationTypeBase)">
            <summary>
            Get types from list that conform to the selected implementation type.
            </summary>
            <param name="types"></param>
            <param name="implementationType"></param>
            <returns>Types for the selected implementation type.</returns>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Fluent.Registration.Bases.RegistrarBase.SelectTypes(System.Collections.Generic.List{System.Type},Bytz.Extensions.DependencyInjection.Fluent.Implementation.BasedOn)">
            <summary>
            Select types that are based-on a specific type.
            </summary>
            <param name="types">Instantiable types within the specified assembly.</param>
            <param name="basedOn">Types based-on a specific type.</param>
            <returns>List of types that are based-on a specific type.</returns>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Fluent.Registration.Bases.RegistrarBase.DerivesFrom(System.Type,System.Type)">
            <summary>
            See if the class is a derivation of another.
            </summary>
            <param name="source">Source type.</param>
            <param name="derivesFrom">Type to that source could be derived from.</param>
            <returns>True if the class can be casted.</returns>
            TODO:    test for IsSubClassOf
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Fluent.Registration.Bases.RegistrarBase.SelectTypes(System.Collections.Generic.List{System.Type},Bytz.Extensions.DependencyInjection.Fluent.Implementation.Implementing)">
            <summary>
            Select types that are implementing a specific interface.
            </summary>
            <param name="types">List of instantiable types.</param>
            <param name="implementing"></param>
            <returns>All types that implement a specific interface.</returns>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Fluent.Registration.Bases.RegistrarBase.SelectTypes(System.Collections.Generic.List{System.Type},Bytz.Extensions.DependencyInjection.Fluent.Implementation.Only)">
            <summary>
            Get the specified type from the list of types.
            </summary>
            <param name="types">List of instantiable types.</param>
            <param name="only">Specific type to select.</param>
            <returns>The specified type from the list of instantiable types.</returns>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Fluent.Registration.Bases.RegistrarBase.AssertInterface``1">
            <summary>
            Assert that TInterface is actually an interface.
            </summary>
            <typeparam name="TInterface">Type to be asserted is a genuine interface.</typeparam>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Fluent.Registration.Bases.RegistrarBase.AssertNotString``1">
            <summary>
            Assert that TClass is not a string type.
            </summary>
            <typeparam name="TClass">Type to be asserted.</typeparam>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Fluent.Registration.Bases.RegistrarBase.AssertNotString(System.Type)">
            <summary>
            Assert that the parameter is not a string type.
            </summary>
            <param name="type">Type to be asserted.</param>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Fluent.Registration.Bases.RegistrarBase.SetType``2">
            <summary>
            Set the type for based-on.
            </summary>
            <typeparam name="TType">Type of implementation.</typeparam>
            <typeparam name="TClass">Type of class for the implementation.</typeparam>
        </member>
        <member name="T:Bytz.Extensions.DependencyInjection.IServiceCollectionExtensions">
            <summary>
            IServiceCollection registration extensions.
            </summary>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.IServiceCollectionExtensions.Register(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{Bytz.Extensions.DependencyInjection.Contracts.IAssembly})">
            <summary>
            Register components with IServiceCollection.
            </summary>
            <param name="services">Instance of IServiceCollection.</param>
            <param name="setup">Method chain to configure IServiceCollection.</param>
            <returns>Instance of IServiceCollection.</returns>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.IServiceCollectionExtensions.AssertLifetime``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,Microsoft.Extensions.DependencyInjection.ServiceLifetime)">
            <summary>
            Assert that all of the registered compontents for TService are of the expected lifetime.
            </summary>
            <typeparam name="TService">Type of service for the components.</typeparam>
            <param name="services">Instance of IServiceCollection.</param>
            <param name="expected">The expected lifetime.</param>
            <exception cref="T:Bytz.Extensions.DependencyInjection.Exceptions.AssertLifetimeException">thrown if not all of the registered components for TService are the expected lifetime.</exception>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.IServiceCollectionExtensions.Register``1(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary>
            Use a registry to register with the IServiceCollection instance.
            </summary>
            <typeparam name="TRegistry">Type of the registry to be used.</typeparam>
            <param name="services">Instance implementing IServiceCollection.</param>
            <returns></returns>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.IServiceCollectionExtensions.Remove``1(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary>
            remove TService from IServiceCollection.
            </summary>
            <typeparam name="TService">TService to be removed.</typeparam>
            <param name="services">Instance implementing IServiceCollection.</param>
            <returns></returns>
        </member>
        <member name="T:Bytz.Extensions.DependencyInjection.IServiceProviderExtensions">
            <summary>
            Extend the IServiceProvider interface.
            </summary>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.IServiceProviderExtensions.AssertResolution``1(System.IServiceProvider)">
            <summary>
            Assert that TService resolution yields results.
            </summary>
            <typeparam name="TService">Type of service for the components.</typeparam>
            <param name="provider">An instance implementing IServiceProvider</param>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.IServiceProviderExtensions.AssertCount``1(System.IServiceProvider,System.Int32)">
            <summary>
            Assert that the resolved count for TService is as expected.
            </summary>
            <typeparam name="TService">Type of service for the components.</typeparam>
            <param name="provider">An instance implementing IServiceProvider.</param>
            <param name="expected">The expected count of resolved components.</param>
        </member>
        <member name="T:Bytz.Extensions.DependencyInjection.Registration.RegistryBase">
            <summary>
            basis for a shared registry to be used by
            both applications and testing in order to 
            allow .
            </summary>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Registration.RegistryBase.OnRegister(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary>
            registry method that is implemented for an application.
            </summary>
            <param name="services">service collection instance.</param>
        </member>
        <member name="M:Bytz.Extensions.DependencyInjection.Registration.RegistryBase.Register(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary>
            common register method to be invoked from a given test / application.
            </summary>
            <param name="services">instance of a service collection.</param>
            <returns>
            the same instance of the service collection  
            parameter. makes use a bit more elegant.
            </returns>
        </member>
    </members>
</doc>
